"use strict";(self.webpackChunkmiaoxi_blog=self.webpackChunkmiaoxi_blog||[]).push([[4963],{66262:(e,i)=>{i.A=(e,i)=>{const o=e.__vccOpts||e;for(const[e,t]of i)o[e]=t;return o}},73855:(e,i,o)=>{o.r(i),o.d(i,{comp:()=>l,data:()=>c});var t=o(20641);const a=o.p+"assets/img/image-20200508122744169.625fc942.png",r=o.p+"assets/img/image-20200508123116104.c05bf580.png",s=o.p+"assets/img/image-20200508123401591.4f569c5b.png",n={},l=(0,o(66262).A)(n,[["render",function(e,i){return(0,t.uX)(),(0,t.CE)("div",null,i[0]||(i[0]=[(0,t.Fv)('<h1 id="csrf-特点和原理" tabindex="-1"><a class="header-anchor" href="#csrf-特点和原理"><span>CSRF 特点和原理</span></a></h1><p>CSRF：Cross Site Request Forgery，跨站请求伪造</p><p>本质是：恶意网站把<strong>正常用户</strong>作为<strong>媒介</strong>，通过模拟正常用户的操作，攻击其<strong>登录过</strong>的站点。</p><img src="'+a+'" alt="image-20200508122744169" style="zoom:50%;"><p>它的原理如下：</p><ol><li>用户访问正常站点，登录后，获取到了正常站点的令牌，以 cookie 的形式保存</li></ol><img src="'+r+'" alt="image-20200508123116104" style="zoom:50%;"><ol start="2"><li>用户访问恶意站点，恶意站点通过某种形式去请求了正常站点（请求伪造），迫使正常用户把令牌传递到正常站点，完成攻击</li></ol><img src="'+s+'" alt="image-20200508123401591" style="zoom:50%;"><h1 id="防御" tabindex="-1"><a class="header-anchor" href="#防御"><span>防御</span></a></h1><h2 id="cookie-的-samesite" tabindex="-1"><a class="header-anchor" href="#cookie-的-samesite"><span>cookie 的 SameSite</span></a></h2><p>现在很多浏览器都支持<strong>禁止跨域附带的 cookie</strong>，只需要把 cookie 设置的<code>SameSite</code>设置为<code>Strict</code>即可</p><p><code>SameSite</code>有以下取值：</p><ul><li><code>Strict</code>：严格，所有跨站请求都不附带 cookie，有时会导致用户体验不好</li><li><code>Lax</code>：宽松，所有跨站的超链接、GET 请求的表单、预加载连接时会发送 cookie，其他情况不发送</li><li><code>None</code>：无限制</li></ul><p>这种方法非常简单，极其有效，但前提条件是：用户不能使用太旧的浏览器</p><h2 id="验证-referer-和-origin" tabindex="-1"><a class="header-anchor" href="#验证-referer-和-origin"><span>验证 referer 和 Origin</span></a></h2><p>页面中的二次请求都会附带 referer 或 Origin 请求头，向服务器表示该请求来自于哪个源或页面，服务器可以通过这个头进行验证</p><p>但某些浏览器的 referer 是可以被用户禁止的，尽管这种情况极少</p><h2 id="使用非-cookie-令牌" tabindex="-1"><a class="header-anchor" href="#使用非-cookie-令牌"><span>使用非 cookie 令牌</span></a></h2><p>这种做法是要求每次请求需要在请求体或请求头中附带 token</p><p>请求的时候：authorization: token</p><h2 id="验证码" tabindex="-1"><a class="header-anchor" href="#验证码"><span>验证码</span></a></h2><p>这种做法是要求每个要防止 CSRF 的请求都必须要附带验证码</p><p>不好的地方是容易把正常的用户逼疯</p><h2 id="表单随机数" tabindex="-1"><a class="header-anchor" href="#表单随机数"><span>表单随机数</span></a></h2><p>这种做法是服务端渲染时，生成一个随机数，客户端提交时要提交这个随机数，然后服务器端进行对比</p><p>该随机数是一次性的</p><p>流程：</p><ol><li>客户端请求服务器，请求添加学生的页面，传递 cookie</li><li>服务器 <ol><li>生成一个随机数，放到 session 中</li><li>生成页面时，表单中加入一个隐藏的表单域<code>&lt;input type=&quot;hidden&quot; name=&quot;hash&quot; value=&quot;&lt;%=session[&#39;key&#39;] %&gt;&quot;&gt;</code></li></ol></li><li>填写好信息后，提交表单，会自动提交隐藏的随机数</li><li>服务器 <ol><li>先拿到 cookie，判断是否登录过</li><li>对比提交过来的随机数和之前的随机数是否一致</li><li>清除掉 session 中的随机数</li></ol></li></ol><h2 id="二次验证" tabindex="-1"><a class="header-anchor" href="#二次验证"><span>二次验证</span></a></h2><p>当做出敏感操作时，进行二次验证</p>',31)]))}]]),c=JSON.parse('{"path":"/posts/more-than-code/network/CSRFAttack.html","title":"CSRF攻击","lang":"zh-CN","frontmatter":{"title":"CSRF攻击","icon":"mdi:bug","order":17,"category":["网络"],"description":"CSRF 特点和原理 CSRF：Cross Site Request Forgery，跨站请求伪造 本质是：恶意网站把正常用户作为媒介，通过模拟正常用户的操作，攻击其登录过的站点。 image-20200508122744169 它的原理如下： 用户访问正常站点，登录后，获取到了正常站点的令牌，以 cookie 的形式保存 image-20200508...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/blog/posts/more-than-code/network/CSRFAttack.html"}],["meta",{"property":"og:site_name","content":"大喵喜的杂货铺"}],["meta",{"property":"og:title","content":"CSRF攻击"}],["meta",{"property":"og:description","content":"CSRF 特点和原理 CSRF：Cross Site Request Forgery，跨站请求伪造 本质是：恶意网站把正常用户作为媒介，通过模拟正常用户的操作，攻击其登录过的站点。 image-20200508122744169 它的原理如下： 用户访问正常站点，登录后，获取到了正常站点的令牌，以 cookie 的形式保存 image-20200508..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-05-27T09:21:11.000Z"}],["meta",{"property":"article:modified_time","content":"2025-05-27T09:21:11.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"CSRF攻击\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-05-27T09:21:11.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Jianshu.Shi\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"cookie 的 SameSite","slug":"cookie-的-samesite","link":"#cookie-的-samesite","children":[]},{"level":2,"title":"验证 referer 和 Origin","slug":"验证-referer-和-origin","link":"#验证-referer-和-origin","children":[]},{"level":2,"title":"使用非 cookie 令牌","slug":"使用非-cookie-令牌","link":"#使用非-cookie-令牌","children":[]},{"level":2,"title":"验证码","slug":"验证码","link":"#验证码","children":[]},{"level":2,"title":"表单随机数","slug":"表单随机数","link":"#表单随机数","children":[]},{"level":2,"title":"二次验证","slug":"二次验证","link":"#二次验证","children":[]}],"git":{"createdTime":1739717238000,"updatedTime":1748337671000,"contributors":[{"name":"damiaoxi","username":"damiaoxi","email":"miaoxi1110@gmail.com","commits":3,"url":"https://github.com/damiaoxi"},{"name":"Jianshu","username":"Jianshu","email":"jianshu.shi@eisgroup.com","commits":2,"url":"https://github.com/Jianshu"}]},"readingTime":{"minutes":2.33,"words":700},"localizedDate":"2025年2月16日","excerpt":"\\n<p>CSRF：Cross Site Request Forgery，跨站请求伪造</p>\\n<p>本质是：恶意网站把<strong>正常用户</strong>作为<strong>媒介</strong>，通过模拟正常用户的操作，攻击其<strong>登录过</strong>的站点。</p>\\n\\n<p>它的原理如下：</p>\\n<ol>\\n<li>用户访问正常站点，登录后，获取到了正常站点的令牌，以 cookie 的形式保存</li>\\n</ol>\\n\\n<ol start=\\"2\\">\\n<li>用户访问恶意站点，恶意站点通过某种形式去请求了正常站点（请求伪造），迫使正常用户把令牌传递到正常站点，完成攻击</li>\\n</ol>","autoDesc":true}')}}]);