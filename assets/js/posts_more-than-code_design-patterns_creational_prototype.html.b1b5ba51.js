"use strict";(self.webpackChunkmiaoxi_blog=self.webpackChunkmiaoxi_blog||[]).push([[3936],{66262:(s,i)=>{i.A=(s,i)=>{const a=s.__vccOpts||s;for(const[s,n]of i)a[s]=n;return a}},20132:(s,i,a)=>{a.r(i),a.d(i,{comp:()=>d,data:()=>c});var n=a(20641);const l=a.p+"assets/img/prototype.0eeb39ef.png",e=a.p+"assets/img/prototype-comic-1-zh.8b2ad8ac.png",t=a.p+"assets/img/prototype-comic-2-zh.86e60c5a.png",p=a.p+"assets/img/prototype-comic-3-zh.fc6ab802.png",h=a.p+"assets/img/structure.c29a3813.png",k=a.p+"assets/img/structure-prototype-cache.23fc4e6e.png",r={},d=(0,a(66262).A)(r,[["render",function(s,i){return(0,n.uX)(),(0,n.CE)("div",null,i[0]||(i[0]=[(0,n.Fv)('<h2 id="意图" tabindex="-1"><a class="header-anchor" href="#意图"><span>意图</span></a></h2><p>原型模式是一种创建型设计模式， 使你能够复制已有对象， 而又无需使代码依赖它们所属的类。</p><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="问题" tabindex="-1"><a class="header-anchor" href="#问题"><span>问题</span></a></h2><p>如果你有一个对象， 并希望生成与其完全相同的一个复制品， 你该如何实现呢？ 首先， 你必须新建一个属于相同类的对象。 然后， 你必须遍历原始对象的所有成员变量， 并将成员变量值复制到新对象中。</p><p>不错！ 但有个小问题。 并非所有对象都能通过这种方式进行复制， 因为有些对象可能拥有私有成员变量， 它们在对象本身以外是不可见的。</p><figure><img src="'+e+'" alt="“从外部” 复制对象并非总是可行" tabindex="0" loading="lazy"><figcaption>“从外部” 复制对象并非总是可行</figcaption></figure><p>直接复制还有另外一个问题。 因为你必须知道对象所属的类才能创建复制品， 所以代码必须依赖该类。 即使你可以接受额外的依赖性， 那还有另外一个问题： 有时你只知道对象所实现的接口， 而不知道其所属的具体类， 比如可向方法的某个参数传入实现了某个接口的任何对象。</p><h2 id="解决方案" tabindex="-1"><a class="header-anchor" href="#解决方案"><span>解决方案</span></a></h2><p>原型模式将克隆过程委派给被克隆的实际对象。 模式为所有支持克隆的对象声明了一个通用接口， 该接口让你能够克隆对象， 同时又无需将代码和对象所属类耦合。 通常情况下， 这样的接口中仅包含一个<code>克隆</code>方法。</p><p>所有的类对<code>克隆</code>方法的实现都非常相似。 该方法会创建一个当前类的对象， 然后将原始对象所有的成员变量值复制到新建的类中。 你甚至可以复制私有成员变量， 因为绝大部分编程语言都允许对象访问其同类对象的私有成员变量。</p><p>支持克隆的对象即为<strong>原型</strong>。 当你的对象有几十个成员变量和几百种类型时， 对其进行克隆甚至可以代替子类的构造。</p><figure><img src="'+t+'" alt="预生成原型可以代替子类的构造" tabindex="0" loading="lazy"><figcaption>预生成原型可以代替子类的构造</figcaption></figure><p>其运作方式如下： 创建一系列不同类型的对象并不同的方式对其进行配置。 如果所需对象与预先配置的对象相同， 那么你只需克隆原型即可， 无需新建一个对象。</p><h2 id="真实世界类比" tabindex="-1"><a class="header-anchor" href="#真实世界类比"><span>真实世界类比</span></a></h2><p>现实生活中， 产品在得到大规模生产前会使用原型进行各种测试。 但在这种情况下， 原型只是一种被动的工具， 不参与任何真正的生产活动。</p><figure><img src="'+p+'" alt="一个细胞的分裂。" tabindex="0" loading="lazy"><figcaption>一个细胞的分裂。</figcaption></figure><p>由于工业原型并不是真正意义上的自我复制， 因此细胞有丝分裂 （还记得生物学知识吗？） 或许是更恰当的类比。 有丝分裂会产生一对完全相同的细胞。 原始细胞就是一个原型， 它在复制体的生成过程中起到了推动作用。</p><h2 id="原型模式结构" tabindex="-1"><a class="header-anchor" href="#原型模式结构"><span>原型模式结构</span></a></h2><h3 id="基本实现" tabindex="-1"><a class="header-anchor" href="#基本实现"><span>基本实现</span></a></h3><figure><img src="'+h+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol><li><strong>原型</strong> （Prototype） 接口将对克隆方法进行声明。 在绝大多数情况下， 其中只会有一个名为 clone 克隆的方法。</li><li><strong>具体原型</strong> （Concrete Prototype） 类将实现克隆方法。 除了将原始对象的数据复制到克隆体中之外， 该方法有时还需处理克隆过程中的极端情况， 例如克隆关联对象和梳理递归依赖等等。</li><li><strong>客户端</strong> （Client） 可以复制实现了原型接口的任何对象。</li></ol><h3 id="原型注册表实现" tabindex="-1"><a class="header-anchor" href="#原型注册表实现"><span>原型注册表实现</span></a></h3><figure><img src="'+k+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>原型注册表</strong> （Prototype Registry） 提供了一种访问常用原型的简单方法， 其中存储了一系列可供随时复制的预生成对象。 最简单的注册表原型是一个 名称 → 原型的哈希表。 但如果需要使用名称以外的条件进行搜索， 你可以创建更加完善的注册表版本。</p><h2 id="伪代码" tabindex="-1"><a class="header-anchor" href="#伪代码"><span>伪代码</span></a></h2><p>在本例中， 原型模式能让你生成完全相同的几何对象副本， 同时无需代码与对象所属类耦合。</p><figure><img src="data:image/png;base64,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" alt="克隆一系列位于同一类层次结构中的对象" tabindex="0" loading="lazy"><figcaption>克隆一系列位于同一类层次结构中的对象</figcaption></figure><p>所有形状类都遵循同一个提供克隆方法的接口。 在复制自身成员变量值到结果对象前， 子类可调用其父类的克隆方法。</p><div class="language-py line-numbers-mode" data-highlighter="shiki" data-ext="py" data-title="py" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 基础原型。</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">abstract </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> Shape </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">is</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    field X: </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">int</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    field Y: </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">int</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    field color: string</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    # 常规构造函数。</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    constructor </span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">Shape</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">is</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        # ……</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    # 原型构造函数。使用已有对象的数值来初始化一个新对象。</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    constructor </span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">Shape</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(source: Shape) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">is</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">        this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        this.X </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> source.X</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        this.Y </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> source.Y</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        this.color </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> source.color</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    # clone（克隆）操作会返回一个形状子类。</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    abstract method </span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">clone</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">():Shape</span></span>\n<span class="line"></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 具体原型。克隆方法会创建一个新对象并将其传递给构造函数。直到构造函数运</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 行完成前，它都拥有指向新克隆对象的引用。因此，任何人都无法访问未完全生</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 成的克隆对象。这可以保持克隆结果的一致。</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> Rectangle extends Shape </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">is</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    field width: </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">int</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    field height: </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">int</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    constructor </span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">Rectangle</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(source: Rectangle) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">is</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        # 需要调用父构造函数来复制父类中定义的私有成员变量。</span></span>\n<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">        super</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(source)</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        this.width </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> source.width</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        this.height </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> source.height</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    method </span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">clone</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">():Shape </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">is</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> new </span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">Rectangle</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(this)</span></span>\n<span class="line"></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> Circle extends Shape </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">is</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    field radius: </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">int</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    constructor </span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">Circle</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(source: Circle) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">is</span></span>\n<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">        super</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(source)</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        this.radius </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> source.radius</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    method </span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">clone</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">():Shape </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">is</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> new </span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">Circle</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(this)</span></span>\n<span class="line"></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 客户端代码中的某个位置。</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> Application </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">is</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    field shapes: array of Shape</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    constructor </span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">Application</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">is</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        Circle circle </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> new </span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">Circle</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        circle.X </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 10</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        circle.Y </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 10</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        circle.radius </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 20</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        shapes.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">add</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(circle)</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        Circle anotherCircle </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> circle.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">clone</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        shapes.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">add</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(anotherCircle)</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        # 变量 `anotherCircle（另一个圆）`与 `circle（圆）`对象的内</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        # 容完全一样。</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        Rectangle rectangle </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> new </span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">Rectangle</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        rectangle.width </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 10</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        rectangle.height </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 20</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        shapes.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">add</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(rectangle)</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    method </span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">businessLogic</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">is</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        # 原型是很强大的东西，因为它能在不知晓对象类型的情况下生成一个与</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        # 其完全相同的复制品。</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        Array shapesCopy </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> new Array of Shapes.</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        # 例如，我们不知晓形状数组中元素的具体类型，只知道它们都是形状。</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        # 但在多态机制的帮助下，当我们在某个形状上调用 `clone（克隆）`</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        # 方法时，程序会检查其所属的类并调用其中所定义的克隆方法。这样，</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        # 我们将获得一个正确的复制品，而不是一组简单的形状对象。</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">        foreach</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (s </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">in</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> shapes) do</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            shapesCopy.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">add</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(s.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">clone</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">())</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        # `shapesCopy（形状副本）`数组中包含 `shape（形状）`数组所有</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        # 子元素的复制品。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="原型模式优缺点" tabindex="-1"><a class="header-anchor" href="#原型模式优缺点"><span>原型模式优缺点</span></a></h2><p>√ 你可以克隆对象， 而无需与它们所属的具体类相耦合。<br> √ 你可以克隆预生成原型， 避免反复运行初始化代码。<br> √ 你可以更方便地生成复杂对象。<br> √ 你可以用继承以外的方式来处理复杂对象的不同配置。<br> × 克隆包含循环引用的复杂对象可能会非常麻烦。</p><h2 id="与其他模式的关系" tabindex="-1"><a class="header-anchor" href="#与其他模式的关系"><span>与其他模式的关系</span></a></h2><ul><li><p>在许多设计工作的初期都会使用工厂方法模式 （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用抽象工厂模式、 原型模式或生成器模式 （更灵活但更加复杂）。</p></li><li><p>抽象工厂模式通常基于一组工厂方法， 但你也可以使用原型模式来生成这些类的方法。</p></li><li><p>原型可用于保存命令模式的历史记录。</p></li><li><p>大量使用组合模式和装饰模式的设计通常可从对于原型的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。</p></li><li><p>原型并不基于继承， 因此没有继承的缺点。 另一方面， 原型需要对被复制对象进行复杂的初始化。 工厂方法基于继承， 但是它不需要初始化步骤。</p></li><li><p>有时候原型可以作为备忘录模式的一个简化版本， 其条件是你需要在历史记录中存储的对象的状态比较简单， 不需要链接其他外部资源， 或者链接可以方便地重建。</p></li><li><p>抽象工厂、 生成器和原型都可以用单例模式来实现。</p></li></ul>',34)]))}]]),c=JSON.parse('{"path":"/posts/more-than-code/design-patterns/creational/prototype.html","title":"原型模式","lang":"zh-CN","frontmatter":{"title":"原型模式","icon":"/assets/images/more-than-code/design-patterns/creational/prototype/prototype-mini.png","order":4,"category":["设计模式"],"description":"意图 原型模式是一种创建型设计模式， 使你能够复制已有对象， 而又无需使代码依赖它们所属的类。 问题 如果你有一个对象， 并希望生成与其完全相同的一个复制品， 你该如何实现呢？ 首先， 你必须新建一个属于相同类的对象。 然后， 你必须遍历原始对象的所有成员变量， 并将成员变量值复制到新对象中。 不错！ 但有个小问题。 并非所有对象都能通过这种方式进行复...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/blog/posts/more-than-code/design-patterns/creational/prototype.html"}],["meta",{"property":"og:site_name","content":"大喵喜的技术杂货铺"}],["meta",{"property":"og:title","content":"原型模式"}],["meta",{"property":"og:description","content":"意图 原型模式是一种创建型设计模式， 使你能够复制已有对象， 而又无需使代码依赖它们所属的类。 问题 如果你有一个对象， 并希望生成与其完全相同的一个复制品， 你该如何实现呢？ 首先， 你必须新建一个属于相同类的对象。 然后， 你必须遍历原始对象的所有成员变量， 并将成员变量值复制到新对象中。 不错！ 但有个小问题。 并非所有对象都能通过这种方式进行复..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-05-07T09:02:49.000Z"}],["meta",{"property":"article:modified_time","content":"2025-05-07T09:02:49.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"原型模式\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-05-07T09:02:49.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Jianshu.Shi\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"意图","slug":"意图","link":"#意图","children":[]},{"level":2,"title":"问题","slug":"问题","link":"#问题","children":[]},{"level":2,"title":"解决方案","slug":"解决方案","link":"#解决方案","children":[]},{"level":2,"title":"真实世界类比","slug":"真实世界类比","link":"#真实世界类比","children":[]},{"level":2,"title":"原型模式结构","slug":"原型模式结构","link":"#原型模式结构","children":[{"level":3,"title":"基本实现","slug":"基本实现","link":"#基本实现","children":[]},{"level":3,"title":"原型注册表实现","slug":"原型注册表实现","link":"#原型注册表实现","children":[]}]},{"level":2,"title":"伪代码","slug":"伪代码","link":"#伪代码","children":[]},{"level":2,"title":"原型模式优缺点","slug":"原型模式优缺点","link":"#原型模式优缺点","children":[]},{"level":2,"title":"与其他模式的关系","slug":"与其他模式的关系","link":"#与其他模式的关系","children":[]}],"git":{"createdTime":1741180358000,"updatedTime":1746608569000,"contributors":[{"name":"damiaoxi","username":"damiaoxi","email":"miaoxi1110@gmail.com","commits":1,"url":"https://github.com/damiaoxi"},{"name":"Jianshu","username":"Jianshu","email":"jianshu.shi@eisgroup.com","commits":5,"url":"https://github.com/Jianshu"}]},"readingTime":{"minutes":7.08,"words":2125},"localizedDate":"2025年3月5日","excerpt":"<h2>意图</h2>\\n<p>原型模式是一种创建型设计模式， 使你能够复制已有对象， 而又无需使代码依赖它们所属的类。</p>\\n<figure><figcaption></figcaption></figure>\\n<h2>问题</h2>\\n<p>如果你有一个对象， 并希望生成与其完全相同的一个复制品， 你该如何实现呢？ 首先， 你必须新建一个属于相同类的对象。 然后， 你必须遍历原始对象的所有成员变量， 并将成员变量值复制到新对象中。</p>\\n<p>不错！ 但有个小问题。 并非所有对象都能通过这种方式进行复制， 因为有些对象可能拥有私有成员变量， 它们在对象本身以外是不可见的。</p>\\n<figure><figcaption>“从外部” 复制对象并非总是可行</figcaption></figure>","autoDesc":true}')}}]);