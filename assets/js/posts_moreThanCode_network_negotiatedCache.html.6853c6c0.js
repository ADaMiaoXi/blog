"use strict";(self.webpackChunkmiaoxi_blog=self.webpackChunkmiaoxi_blog||[]).push([[5671],{66262:(e,i)=>{i.A=(e,i)=>{const a=e.__vccOpts||e;for(const[e,p]of i)a[e]=p;return a}},16388:(e,i,a)=>{a.r(i),a.d(i,{comp:()=>h,data:()=>g});var p=a(20641);const s=a.p+"assets/img/image-20240227171814802.778c02cb.png",l=a.p+"assets/img/image-20240227175829394.7393a309.png",t=a.p+"assets/img/image-20240227180114311.af4153d0.png",o=a.p+"assets/img/image-20240227182004974.9e16da75.png",n=a.p+"assets/img/image-20240227202156914.04081d01.png",c=a.p+"assets/img/image-20240227202543760.e08cac08.png",d=a.p+"assets/img/image-20240227203816953.7d81b113.png",r={},h=(0,a(66262).A)(r,[["render",function(e,i){return(0,p.uX)(),(0,p.CE)("div",null,i[0]||(i[0]=[(0,p.Fv)('<h2 id="缓存的基本原理" tabindex="-1"><a class="header-anchor" href="#缓存的基本原理"><span>缓存的基本原理</span></a></h2><p>在一个C/S结构中，最基本的缓存分为两种:</p><ul><li>客户端缓存</li><li>服务器缓存</li></ul><p>本文仅讨论客户端缓存</p><p>所谓客户端缓存，顾名思义，是将某一次的响应结果保存在客户端（比如浏览器）中，而后续的请求仅需要从缓存中读取即可，极大的降低了服务器的处理压力。</p><p>客户端缓存的原理如下:</p><figure><img src="'+s+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><blockquote><p>这只是一个简易的原理图，实际情况可能有差异</p></blockquote><p>这里就设计到一个缓存策略的问题，这些问题包括:</p><ul><li>哪些资源需要加入到缓存，哪些不需要？</li><li>缓存的时间是多久呢？</li><li>如果服务器的资源有改动，客户端如何更新缓存呢？</li></ul><h2 id="来自服务器的缓存指令" tabindex="-1"><a class="header-anchor" href="#来自服务器的缓存指令"><span>来自服务器的缓存指令</span></a></h2><p>当客户端发出一个 <code>get</code> 请求到服务器，服务器可能有以下的内心活动:「你请求的这个资源，我很少会改动它，干脆你把它缓存起来吧，以后就不要来烦我了」<br> 为了表达这个美好的愿望，服务器在响应头中加入了以下内容：</p><div class="language-yaml line-numbers-mode" data-highlighter="shiki" data-ext="yaml" data-title="yaml" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">Cache-Control</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">max-age=3600</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> </span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">ETag</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">W/&quot;121-171ca289ebf&quot;</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">Date</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">Thu, 30 Apr 2020 12:39:56 GHT</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">Last Modified</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">Thu, 30 Apr 2020 08:16:31 GHT</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个响应头表达了下面的信息:</p><ul><li><code>Cache-Control: max-age=3600</code>，我希望你把这个资源缓存起来，缓存时间是3600秒（1小时）</li><li><code>ETag: W/&quot;121-171ca289ebf&quot;</code>，这个资源的编号是 <code>W/&quot;121-171ca289ebf&quot;</code></li><li><code>Date:Thu,30 Apr 2020 12:39:56 GMT</code>，我给你响应这个资源的服务器时间是格林威治时间 <code>2020-04-30 12:39:56</code></li><li><code>Last-Modified: Thu, 30 Apr 2020 08:16:31 GMT</code>， 这个资源的上一次修改时间是格林威治时间 <code>2020-04-30 08:16:31</code></li></ul><p>这个美好的缓存愿望，就这样通过响应头传递给客户端了</p><p>如果客户端是其他应用程序，可能并不会理会服务器的愿望，也就是说，可能根本不会缓存任何东西。</p><p>但是凑巧客户端是一个浏览器，它和服务器一直以来都是相亲相爱的小伙伴，当它看到服务器的这个响应头表达的美好愿望后，立即忙起来:</p><ul><li>浏览器把这次请求得到的响应体缓存到本地文件中</li><li>浏览器标记这次请求的请求方法和请求路径</li><li>浏览器标记这次缓存的时间是3600秒</li><li>浏览器记录服务器的响应时间是格林威治时间 <code>2020-04-30 12:39:56</code></li><li>浏览器记录服务器给予的资源编号 <code>W/&quot;121-171ca289ebf</code></li><li>浏览器记录资源的上一次修改时间是格林威治时间 <code>2020-04-30 08:16:31</code></li></ul><p>这一次的记录非常重要，它为以后浏览器要不要去请求服务器提供了各种依据。</p><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="来自客户端的缓存指令" tabindex="-1"><a class="header-anchor" href="#来自客户端的缓存指令"><span>来自客户端的缓存指令</span></a></h2><p>当客户端收拾好行李，准备再次请求 <code>GET/index.js</code> 时，它突然想起了一件事：我需要的东西在不在缓存里呢?</p><p>此时，客户端会到缓存中去寻找是否有缓存的资源</p><p>寻找的过程如下:</p><ol><li><p>缓存中是否有匹配的请求方法和路径?</p></li><li><p>如果有，该缓存资源是否还有效呢?</p></li></ol><p>以上两个验证会导致浏览器产生不同的行为</p><figure><img src="'+t+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>要验证是否有匹配的缓存非常简单，只需要验证当前的请求方法 <code>GET</code> 和当前的请求路径 <code>/index.js</code> 是否有对应的缓存存在即可<br> 如果没有，就直接请求服务器，就和第一次请求服务器时一样，这种情况没有什么好讨论的。</p><p>关键在于验证缓存是否有效</p><p>如何验证呢?</p><p>非常简单，就是把 <code>max-age + Date</code>，得到一个过期时间，看看这个过期时间是否大于当前时间。</p><p>如果是，则表示缓存还没有过期，仍然有效，如果不是，则表示缓存失效。</p><h3 id="缓存有效" tabindex="-1"><a class="header-anchor" href="#缓存有效"><span>缓存有效</span></a></h3><p>当浏览器发现缓存有效时，完全不会请求服务器，直接使用缓存即可得到结果</p><p>此时，如果你断开网络，会发现资源仍然可用</p><p>这种情况会极大的降低服务器压力，但当服务器更改了资源后，浏览器是不知道的，只要缓存有效，它就会直接使用缓存</p><h3 id="缓存无效" tabindex="-1"><a class="header-anchor" href="#缓存无效"><span>缓存无效</span></a></h3><p>当浏览器发现缓存已经过期，它并不会简单的把缓存删除，而是抱着一丝希望，想问问服务器，我这个缓存还能继续使用吗?</p><p>于是，浏览器向服务器发出了一个<strong>带缓存的请求</strong>，又称之为<strong>协商缓存</strong></p><p>所谓带缓存的请求，无非就是加入了以下的请求头：</p><div class="language-yaml line-numbers-mode" data-highlighter="shiki" data-ext="yaml" data-title="yaml" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">If-Modified-Since</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">Thu, 30 Apr 2020 08:16:31 GMT</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">If-None-Match</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">W/&quot;121- 171ca289ebfn</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>它们表达了下面的信息:</p><ul><li><code>If-Modified-Since: Thu, 30 Apr 2020 08:16:31 GMT</code>，亲，你曾经告诉我，这个资源的上一次修改时间是格林威治时间 <code>2020-04-30 08:16:31</code> ，请问这个资源在这个时间之后有发生变动吗?</li><li><code>If-None-Match; W/&quot;121-171ca289ebf</code>， 亲，你曾经告诉我，这个资源的编号是 <code>W/121-171ca289ebf</code>，请问这个资源的编号发生变动了吗?</li></ul><p>其实，这两个问题可以合并为一个问题:快说!资源到底变了没有!</p><p>之所以要发两个信息，是为了兼容不同的服务器，因为有些服务器只认 <code>If- Modified-Since</code>，有些服务器只认<code>If-None-Match</code>，有些服务器两个都认。</p><blockquote><p>目前的很多服务器，只要发现 <code>If-None-Match</code> 存在，就不会去看 <code>If-Modified-Since</code><br><code>If-Modified-Since</code> 是http1.0版本的规范，<code>If-None-Match</code> 是 http1.1 的规范</p></blockquote><p>此时，问题又抛给了服务器，接下来，就是服务器的表演时间了</p><ul><li>缓存已经失效</li><li>缓存仍然有效</li></ul><p>如果是第一种情况 -- <strong>缓存已经失效</strong>，那么非常简单，服务器再次给予一个正常的响应(响应码200带响应体) ，同时可以附带上新的缓存指令，这就回到了上一节 -- 来自服务器的缓存指令。</p><p>这样一来，客户端就会重新缓存新的内容</p><p>但如果服务器觉得缓存仍然有效，它可以通过一种极其简单的方式告诉客户端：</p><ul><li>响应码为 <code>304 Not Modified</code></li><li>无响应体</li><li>响应头带上新的缓存指令，见上一节 -- 来自服务器的缓存指令</li></ul><p>这样一来，就相当于告诉客户端:「你的缓存 资源仍然可用，我给你一个新的缓存时间，你那边更新一下就可以了」</p><p>于是，客户端就继续 happy 的使用缓存了</p><p>这样一来，可以最大程度的减少网络传输，因为如果资源还有效，服务器就不会传输消息体</p><p>它们完整的交互过程如下:</p><figure><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="一些细节-了解" tabindex="-1"><a class="header-anchor" href="#一些细节-了解"><span>一些细节（了解）</span></a></h2><p>上面描述了客户端缓存的基本概念和过程，但其中仍然有不少细节值得我们注意：</p><h3 id="cache-control" tabindex="-1"><a class="header-anchor" href="#cache-control"><span>Cache-Control</span></a></h3><p>在上述的讲解中，<code>Cache-Control</code>是服务器向客户端响应的一个消息头，它提供了一个 <code>max-age</code><br> 用于指定缓存时间。<br> 实际上，<code>Cache-Control</code> 还可以设置下面一个或多个值：</p><ul><li><p><code>public</code>：指示服务器资源是公开的。比如有一个页面资源，所有人看到的都是-样的。这个<br> 值对于浏览器而言没有什么意义，但可能在某些场景可能有用。本着「我告知，你随意」的原<br> 则，http协议中很多时候都是客户端或服务器告诉另一端详细的信息，至于另一端用不用，<br> 完全看它自己。</p></li><li><p><code>private</code>：指示服务器资源是私有的。比如有一个页面资源，每个用户看到的都不一样。这<br> 个值对于浏览器而言没有什么意义，但可能在某些场景可能有用。本着「我告知，你随意」的<br> 原则，http 协议中很多时候都是客户端或服务器告诉另一端详细的信息，至于另一端用不<br> 用，完全看它自己。</p></li><li><p><code>no-cache</code>：告知客户端，你可以缓存这个资源，但是不要直接使用它。当你缓存之后，后续<br> 的每一次请求都需要附带缓存指令，让服务器告诉你这个资源有没有过期。见:「来自客户端<br> 的缓存指令 - 缓存无效」</p></li><li><p><code>no-store</code>：告知客户端，不要对这个资源做任何的缓存，之后的每-次请求都按照正常的普<br> 通请求进行。若设置了这个值，浏览器将不会对该资源做出任何的缓存处理。</p></li><li><p><code>max-age</code>：不再赘述</p></li></ul><p>比如，<code>Cache-Control: public, max-age=3600</code> 表示这是一个公开资源，请缓存1个小时。</p><h3 id="expire" tabindex="-1"><a class="header-anchor" href="#expire"><span>Expire</span></a></h3><p>在 http1.0 版本中，是通过 <code>Expires</code> 响应头来指定过期时间点的，例如:</p><div class="language-yaml line-numbers-mode" data-highlighter="shiki" data-ext="yaml" data-title="yaml" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">Expires</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">Thu, 30 Apr 2020 23:38:38 GMT</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>到了http1.1 版本，已更改为通过Cache-Control 的max-age来记录了。</p><h3 id="记录缓存时的有效期" tabindex="-1"><a class="header-anchor" href="#记录缓存时的有效期"><span>记录缓存时的有效期</span></a></h3><p>浏览器会按照服务器响应头的要求，自动记录缓存到本地文件，并设置各种相关信息</p><p>在这些信息中，有效期尤为关键，它决定了这个缓存可以使用多久</p><p>浏览器会根据服务器不同的响应情况，设置不同的有效期</p><p>具体的有效期设置，按照下面的流程进行：</p><figure><img src="'+n+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>例如，当max-age设置为0时，缓存立即过期</p><p>虽然立即过期，但缓存仍然被记录下来，后续的请求通过缓存指令发送到服务器，来确认资源是否被更改。</p><p>因此，<code>Cache-Control: max-age=0</code> 类似于 <code>Cache-Control: no-cache</code></p><h3 id="pragma" tabindex="-1"><a class="header-anchor" href="#pragma"><span>Pragma</span></a></h3><p>这是 <code>http1.0</code> 版本的消息头</p><p>当该消息头出现在请求中时，是向服务器表达:不要考虑任何缓存，给我一个正常的结果。</p><p>在 <code>http1.1</code>版本中，可以在请求头中加入<code>Cache-Control: no-cache</code> 实现同样的含义。</p><blockquote><p>是的，<code>Cache-Control</code> 可以出现在请求头中</p></blockquote><p>在Chrome浏览器中调试时，如果勾选了 <code>Disable cache</code> ，则发送的请求中会附带该信息</p><figure><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="vary" tabindex="-1"><a class="header-anchor" href="#vary"><span>Vary</span></a></h3><p>有的时候，是否有缓存，不仅仅是判断请求方法和请求路径是否匹配，可能还要判断头部信息是否匹配。</p><p>此时，就可以使用Vary 字段来指定要区分的消息头</p><p>比如，当使用GET /personal.html 请求服务器时，请求头中cookie的值不一样，得到的页面也不一样</p><p>如果还按照之前的做法，仅仅匹配请求方法和请求路径，如果cookie 变动，你可能得到的仍然是之前的页面。</p><p>正确的做法如下:</p><figure><img src="'+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="_15-4-6-使用版本号或hash" tabindex="-1"><a class="header-anchor" href="#_15-4-6-使用版本号或hash"><span>15.4.6 使用版本号或hash</span></a></h4><p>如果你是一个前端工程师，使用过vue或其他基于webpack 搭建的工程。</p><p>你会发现打包的结果中很多文件名类似于这样:<br><code>app .68297cd8. css</code></p><p>文件的中间部分使用了 hash 值。</p><p>这样做的好处是，可以让客户端大胆的、长时间的缓存该文件，减轻服务器的压力。</p><p>当文件改动后，它的文件hash值也会随之而变，比如变成了<code>app.446fccb8.css</code></p><p>这样一来，客户端要请求新的文件时，就会发现路径从 <code>/app.68297cd8.css</code> 变成了 <code>app.446fccb8.css</code>，由于之前的缓存路径无法匹配到，因此就会发送新的请求来获取新资源了。</p><p>以上是现代流行的做法。</p><p>而在古老的年代，还没有构建工具出现时，人们使用的办法是在资源路径后面加入版本号来获取新版本的文件。</p><p>比如，页面中引入了一个css资源app.css ，它可能的引入方式是：</p><p><code>&lt;Link href=&quot;/app.css?v=1.0.0&quot;&gt;</code></p><p>这样一来，缓存的路径是 <code>/app.css?v=1.0.0</code></p><p>当服务器的版本发生变化时，可以给予新的版本号，让 html 中的路径发生变动。</p><p><code>&lt;link href=&quot;/app.css?v=1.0.1&quot;&gt;</code></p><p>由于新的路径无法命中缓存，于是浏览器就会发送新的普通请求来获取这个资源。</p>',106)]))}]]),g=JSON.parse('{"path":"/posts/moreThanCode/network/negotiatedCache.html","title":"HTTP缓存协议（协商缓存）","lang":"zh-CN","frontmatter":{"title":"HTTP缓存协议（协商缓存）","icon":"octicon:cache-24","order":15,"category":["网络"],"description":"缓存的基本原理 在一个C/S结构中，最基本的缓存分为两种: 客户端缓存 服务器缓存 本文仅讨论客户端缓存 所谓客户端缓存，顾名思义，是将某一次的响应结果保存在客户端（比如浏览器）中，而后续的请求仅需要从缓存中读取即可，极大的降低了服务器的处理压力。 客户端缓存的原理如下: 这只是一个简易的原理图，实际情况可能有差异 这里就设计到一个缓存策略的问题，这些...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/blog/posts/moreThanCode/network/negotiatedCache.html"}],["meta",{"property":"og:site_name","content":"大喵喜的技术杂货铺"}],["meta",{"property":"og:title","content":"HTTP缓存协议（协商缓存）"}],["meta",{"property":"og:description","content":"缓存的基本原理 在一个C/S结构中，最基本的缓存分为两种: 客户端缓存 服务器缓存 本文仅讨论客户端缓存 所谓客户端缓存，顾名思义，是将某一次的响应结果保存在客户端（比如浏览器）中，而后续的请求仅需要从缓存中读取即可，极大的降低了服务器的处理压力。 客户端缓存的原理如下: 这只是一个简易的原理图，实际情况可能有差异 这里就设计到一个缓存策略的问题，这些..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-01T15:00:17.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-01T15:00:17.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"HTTP缓存协议（协商缓存）\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-01T15:00:17.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Jianshu.Shi\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"缓存的基本原理","slug":"缓存的基本原理","link":"#缓存的基本原理","children":[]},{"level":2,"title":"来自服务器的缓存指令","slug":"来自服务器的缓存指令","link":"#来自服务器的缓存指令","children":[]},{"level":2,"title":"来自客户端的缓存指令","slug":"来自客户端的缓存指令","link":"#来自客户端的缓存指令","children":[{"level":3,"title":"缓存有效","slug":"缓存有效","link":"#缓存有效","children":[]},{"level":3,"title":"缓存无效","slug":"缓存无效","link":"#缓存无效","children":[]}]},{"level":2,"title":"一些细节（了解）","slug":"一些细节-了解","link":"#一些细节-了解","children":[{"level":3,"title":"Cache-Control","slug":"cache-control","link":"#cache-control","children":[]},{"level":3,"title":"Expire","slug":"expire","link":"#expire","children":[]},{"level":3,"title":"记录缓存时的有效期","slug":"记录缓存时的有效期","link":"#记录缓存时的有效期","children":[]},{"level":3,"title":"Pragma","slug":"pragma","link":"#pragma","children":[]},{"level":3,"title":"Vary","slug":"vary","link":"#vary","children":[]}]}],"git":{"createdTime":1739717238000,"updatedTime":1740841217000,"contributors":[{"name":"damiaoxi","username":"damiaoxi","email":"miaoxi1110@gmail.com","commits":3,"url":"https://github.com/damiaoxi"}]},"readingTime":{"minutes":10.58,"words":3174},"localizedDate":"2025年2月16日","excerpt":"<h2>缓存的基本原理</h2>\\n<p>在一个C/S结构中，最基本的缓存分为两种:</p>\\n<ul>\\n<li>客户端缓存</li>\\n<li>服务器缓存</li>\\n</ul>\\n<p>本文仅讨论客户端缓存</p>\\n<p>所谓客户端缓存，顾名思义，是将某一次的响应结果保存在客户端（比如浏览器）中，而后续的请求仅需要从缓存中读取即可，极大的降低了服务器的处理压力。</p>\\n<p>客户端缓存的原理如下:</p>\\n<figure><figcaption></figcaption></figure>\\n<blockquote>\\n<p>这只是一个简易的原理图，实际情况可能有差异</p>\\n</blockquote>","autoDesc":true}')}}]);