"use strict";(self.webpackChunkmiaoxi_blog=self.webpackChunkmiaoxi_blog||[]).push([[7985],{66262:(e,i)=>{i.A=(e,i)=>{const n=e.__vccOpts||e;for(const[e,o]of i)n[e]=o;return n}},51476:(e,i,n)=>{n.r(i),n.d(i,{comp:()=>l,data:()=>a});var o=n(20641);const t={},l=(0,n(66262).A)(t,[["render",function(e,i){return(0,o.uX)(),(0,o.CE)("div",null,i[0]||(i[0]=[(0,o.Fv)('<h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介"><span>简介</span></a></h2><p>Yarn 是由 Facebook、Google、Exponent 和 Tilde 联合推出的一个新的 JavaScript 包管理工具，<strong>它仍然使用 NPM 的 registry</strong>，但提供了全新的 CLI 来对包进行管理。</p><p>过去，由于 早期 NPM 存在以下问题，Yarn 的出现极大地抢占了 NPM 的市场份额。</p><ul><li>依赖目录嵌套层次深：早期 NPM 的依赖是嵌套的，这在 Windows 系统上是一个严重问题，由于众所周知的原因，Windows 系统无法支持过深的目录结构。</li><li>下载速度慢： <ul><li>由于嵌套层次的问题，NPM 对包的下载只能是串行的，即前一个包下载完后才会下载下一个包，导致带宽资源没有被充分利用。</li><li>多个相同版本的包会被重复下载。</li></ul></li><li>控制台输出繁杂：早期 NPM 安装包时，每安装一个依赖，就会输出依赖的详细信息，导致一次安装有大量信息输出到控制台，遇到错误时极难排查。</li><li>执行指令困难： 早期 NPM 没有执行依赖包指令的工具，执行指令需要手动执行 <code>bin</code> 目录下的文件，需要写出完整路径。（没有 <code>npx</code>）</li><li>工程移植问题：由于 NPM 的版本依赖可以是模糊的，可能导致工程移植后依赖的确切版本不一致。(没有 package.json 文件)</li></ul><p>针对上述问题，Yarn 从诞生之初就已经解决，其采用了以下手段：</p><ul><li>使用扁平的目录结构</li><li>并行下载</li><li>使用本地缓存</li><li>控制台仅输出关键信息</li><li>使用 yarn.lock 文件记录确切依赖</li></ul><p>此外，Yarn 还优化了以下内容：</p><ul><li>增加了某些功能强大的命令</li><li>让既有的命令更加语义化</li><li>本地安装的 CLI 工具可以使用 <code>yarn</code> 直接启动</li><li>将全局安装的目录当作一个普通的工程，生成 package.json 文件，便于全局安装移植</li></ul><p>Yarn 的出现给 NPM 带来了巨大的压力。很快，NPM 借鉴了 Yarn 的先进理念，不断对自身进行优化。到了 <code>npm@6</code> 版本，几乎完全解决了上述问题：</p><ul><li>目录扁平化</li><li>并行下载</li><li>本地缓存</li><li>使用 package-lock.json 记录确切依赖</li><li>增加了大量的命令别名</li><li>内置了 <code>npx</code>，可以启动本地的 CLI 工具</li><li>极大简化了控制台输出</li></ul><p><code>npm@6</code> 之后，可以说 NPM 已经和 Yarn 非常接近，甚至没有差距。许多新项目又重新从 Yarn 转回到 NPM。</p>',11)]))}]]),a=JSON.parse('{"path":"/posts/web/frontend-engineering/package-manager/yarn.html","title":"Yarn","lang":"zh-CN","frontmatter":{"title":"Yarn","icon":"logos:yarn","order":2,"category":["Package manager"],"description":"简介 Yarn 是由 Facebook、Google、Exponent 和 Tilde 联合推出的一个新的 JavaScript 包管理工具，它仍然使用 NPM 的 registry，但提供了全新的 CLI 来对包进行管理。 过去，由于 早期 NPM 存在以下问题，Yarn 的出现极大地抢占了 NPM 的市场份额。 依赖目录嵌套层次深：早期 NPM 的...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/blog/posts/web/frontend-engineering/package-manager/yarn.html"}],["meta",{"property":"og:site_name","content":"大喵喜的杂货铺"}],["meta",{"property":"og:title","content":"Yarn"}],["meta",{"property":"og:description","content":"简介 Yarn 是由 Facebook、Google、Exponent 和 Tilde 联合推出的一个新的 JavaScript 包管理工具，它仍然使用 NPM 的 registry，但提供了全新的 CLI 来对包进行管理。 过去，由于 早期 NPM 存在以下问题，Yarn 的出现极大地抢占了 NPM 的市场份额。 依赖目录嵌套层次深：早期 NPM 的..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-07-28T08:42:57.000Z"}],["meta",{"property":"article:modified_time","content":"2025-07-28T08:42:57.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Yarn\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-07-28T08:42:57.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Jianshu.Shi\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"简介","slug":"简介","link":"#简介","children":[]}],"git":{"createdTime":1753692177000,"updatedTime":1753692177000,"contributors":[{"name":"Jianshu","username":"Jianshu","email":"jianshu.shi@eisgroup.com","commits":1,"url":"https://github.com/Jianshu"}]},"readingTime":{"minutes":2.17,"words":652},"localizedDate":"2025年7月28日","excerpt":"<h2>简介</h2>\\n<p>Yarn 是由 Facebook、Google、Exponent 和 Tilde 联合推出的一个新的 JavaScript 包管理工具，<strong>它仍然使用 NPM 的 registry</strong>，但提供了全新的 CLI 来对包进行管理。</p>\\n<p>过去，由于 早期 NPM 存在以下问题，Yarn 的出现极大地抢占了 NPM 的市场份额。</p>\\n<ul>\\n<li>依赖目录嵌套层次深：早期 NPM 的依赖是嵌套的，这在 Windows 系统上是一个严重问题，由于众所周知的原因，Windows 系统无法支持过深的目录结构。</li>\\n<li>下载速度慢：\\n<ul>\\n<li>由于嵌套层次的问题，NPM 对包的下载只能是串行的，即前一个包下载完后才会下载下一个包，导致带宽资源没有被充分利用。</li>\\n<li>多个相同版本的包会被重复下载。</li>\\n</ul>\\n</li>\\n<li>控制台输出繁杂：早期 NPM 安装包时，每安装一个依赖，就会输出依赖的详细信息，导致一次安装有大量信息输出到控制台，遇到错误时极难排查。</li>\\n<li>执行指令困难： 早期 NPM 没有执行依赖包指令的工具，执行指令需要手动执行 <code>bin</code> 目录下的文件，需要写出完整路径。（没有 <code>npx</code>）</li>\\n<li>工程移植问题：由于 NPM 的版本依赖可以是模糊的，可能导致工程移植后依赖的确切版本不一致。(没有 package.json 文件)</li>\\n</ul>","autoDesc":true}')}}]);