"use strict";(self.webpackChunkmiaoxi_blog=self.webpackChunkmiaoxi_blog||[]).push([[2200],{66262:(e,t)=>{t.A=(e,t)=>{const i=e.__vccOpts||e;for(const[e,o]of t)i[e]=o;return i}},36793:(e,t,i)=>{i.r(t),i.d(t,{comp:()=>c,data:()=>l});var o=i(20641);const r={},c=(0,i(66262).A)(r,[["render",function(e,t){return(0,o.uX)(),(0,o.CE)("div",null,t[0]||(t[0]=[(0,o.Fv)("<ul><li><p>从定义数据角度分析</p><ul><li><p>ref 用来定义：基本数据类型。</p></li><li><p>reactive 用来定义：对象（或数组）类型数据。</p><blockquote><p>备注：ref 也可以用来定义对象（或数组）类型数据，它内部会自欧东通过 <code>reactive</code> 转为代理对象</p></blockquote></li></ul></li><li><p>从原理角度对比：</p><ul><li>ref 通过 <code>Object。defineProperty()</code> 的 <code>get</code> 与 <code>set</code> 来实现响应式（数据劫持）。</li><li>reactive 通过使用 Proxy 来实现响应式（数据劫持），并通过Reflect操作源对象内部的数据。</li></ul></li><li><p>从使用角度对比：</p><ul><li>ref定义的数据：操作数据需要<code>.value</code>，读取数据时模板中直接读取不需要<code>.value</code>。</li><li>reactive定义的数据：操作数据与读取数据，均不需要<code>.value</code>。</li></ul></li></ul>",1)]))}]]),l=JSON.parse('{"path":"/posts/web/framework/vue/reactive-and-ref.html","title":"reactive 对比 ref","lang":"zh-CN","frontmatter":{"title":"reactive 对比 ref","icon":"file-icons:closuretemplate","order":4,"category":["Vue"],"description":"从定义数据角度分析 ref 用来定义：基本数据类型。 reactive 用来定义：对象（或数组）类型数据。 备注：ref 也可以用来定义对象（或数组）类型数据，它内部会自欧东通过 reactive 转为代理对象 从原理角度对比： ref 通过 Object。defineProperty() 的 get 与 set 来实现响应式（数据劫持）。 react...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/blog/posts/web/framework/vue/reactive-and-ref.html"}],["meta",{"property":"og:site_name","content":"大喵喜的杂货铺"}],["meta",{"property":"og:title","content":"reactive 对比 ref"}],["meta",{"property":"og:description","content":"从定义数据角度分析 ref 用来定义：基本数据类型。 reactive 用来定义：对象（或数组）类型数据。 备注：ref 也可以用来定义对象（或数组）类型数据，它内部会自欧东通过 reactive 转为代理对象 从原理角度对比： ref 通过 Object。defineProperty() 的 get 与 set 来实现响应式（数据劫持）。 react..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-05-08T10:14:37.000Z"}],["meta",{"property":"article:modified_time","content":"2025-05-08T10:14:37.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"reactive 对比 ref\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-05-08T10:14:37.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Jianshu.Shi\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[],"git":{"createdTime":1745229849000,"updatedTime":1746699277000,"contributors":[{"name":"Jianshu","username":"Jianshu","email":"jianshu.shi@eisgroup.com","commits":3,"url":"https://github.com/Jianshu"}]},"readingTime":{"minutes":0.65,"words":194},"localizedDate":"2025年4月21日","excerpt":"<ul>\\n<li>\\n<p>从定义数据角度分析</p>\\n<ul>\\n<li>\\n<p>ref 用来定义：基本数据类型。</p>\\n</li>\\n<li>\\n<p>reactive 用来定义：对象（或数组）类型数据。</p>\\n<blockquote>\\n<p>备注：ref 也可以用来定义对象（或数组）类型数据，它内部会自欧东通过 <code>reactive</code> 转为代理对象</p>\\n</blockquote>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<p>从原理角度对比：</p>\\n<ul>\\n<li>ref 通过 <code>Object。defineProperty()</code> 的 <code>get</code> 与 <code>set</code> 来实现响应式（数据劫持）。</li>\\n<li>reactive 通过使用 Proxy 来实现响应式（数据劫持），并通过Reflect操作源对象内部的数据。</li>\\n</ul>\\n</li>\\n<li>\\n<p>从使用角度对比：</p>\\n<ul>\\n<li>ref定义的数据：操作数据需要<code>.value</code>，读取数据时模板中直接读取不需要<code>.value</code>。</li>\\n<li>reactive定义的数据：操作数据与读取数据，均不需要<code>.value</code>。</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}')}}]);