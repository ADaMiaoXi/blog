"use strict";(self.webpackChunkmiaoxi_blog=self.webpackChunkmiaoxi_blog||[]).push([[1239],{66262:(i,s)=>{s.A=(i,s)=>{const a=i.__vccOpts||i;for(const[i,n]of s)a[i]=n;return a}},50617:(i,s,a)=>{a.r(s),a.d(s,{comp:()=>r,data:()=>c});var n=a(20641);const l=a.p+"assets/img/visitor.a2822d2a.png",e=a.p+"assets/img/problem1.37f3ad86.png",t=a.p+"assets/img/problem2-zh.e925a680.png",h=a.p+"assets/img/visitor-comic-1.ce6591f2.png",p=a.p+"assets/img/structure-zh.0d4f132e.png",k=a.p+"assets/img/example.553a0830.png",d={},r=(0,a(66262).A)(d,[["render",function(i,s){const a=(0,n.g2)("RouteLink");return(0,n.uX)(),(0,n.CE)("div",null,[s[15]||(s[15]=(0,n.Fv)('<h2 id="意图" tabindex="-1"><a class="header-anchor" href="#意图"><span>意图</span></a></h2><p>访问者模式是一种行为设计模式， 它能将算法与其所作用的对象隔离开来。</p><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="问题" tabindex="-1"><a class="header-anchor" href="#问题"><span>问题</span></a></h2><p>假如你的团队开发了一款能够使用巨型图像中地理信息的应用程序。 图像中的每个节点既能代表复杂实体 （例如一座城市）， 也能代表更精细的对象 （例如工业区和旅游景点等）。 如果节点代表的真实对象之间存在公路， 那么这些节点就会相互连接。 在程序内部， 每个节点的类型都由其所属的类来表示， 每个特定的节点则是一个对象。</p><figure><img src="'+e+'" alt="将图像导出为 XML。" tabindex="0" loading="lazy"><figcaption>将图像导出为 XML。</figcaption></figure><p>一段时间后， 你接到了实现将图像导出到 XML 文件中的任务。 这些工作最初看上去非常简单。 你计划为每个节点类添加导出函数， 然后递归执行图像中每个节点的导出函数。 解决方案简单且优雅： 使用多态机制可以让导出方法的调用代码不会和具体的节点类相耦合。</p><p>但你不太走运， 系统架构师拒绝批准对已有节点类进行修改。 他认为这些代码已经是产品了， 不想冒险对其进行修改， 因为修改可能会引入潜在的缺陷。</p><figure><img src="'+t+'" alt="所有节点的类中都必须添加导出至 XML 文件的方法， 但如果在修改代码的过程中引入了任何缺陷， 那么整个程序都会面临风险。" tabindex="0" loading="lazy"><figcaption>所有节点的类中都必须添加导出至 XML 文件的方法， 但如果在修改代码的过程中引入了任何缺陷， 那么整个程序都会面临风险。</figcaption></figure><p>此外， 他还质疑在节点类中包含导出 XML 文件的代码是否有意义。 这些类的主要工作是处理地理数据。 导出 XML 文件的代码放在这里并不合适。</p><p>还有另一个原因， 那就是在此项任务完成后， 营销部门很有可能会要求程序提供导出其他类型文件的功能， 或者提出其他奇怪的要求。 这样你很可能会被迫再次修改这些重要但脆弱的类。</p><h2 id="解决方案" tabindex="-1"><a class="header-anchor" href="#解决方案"><span>解决方案</span></a></h2><p>访问者模式建议将新行为放入一个名为访问者的独立类中， 而不是试图将其整合到已有类中。 现在， 需要执行操作的原始对象将作为参数被传递给访问者中的方法， 让方法能访问对象所包含的一切必要数据。</p><p>如果现在该操作能在不同类的对象上执行会怎么样呢？ 比如在我们的示例中， 各节点类导出 XML 文件的实际实现很可能会稍有不同。 因此， 访问者类可以定义一组 （而不是一个） 方法， 且每个方法可接收不同类型的参数， 如下所示：</p><div class="language-py line-numbers-mode" data-highlighter="shiki" data-ext="py" data-title="py" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ExportVisitor implements Visitor </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">is</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    method </span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">doForCity</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(City c) { …… }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    method </span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">doForIndustry</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(Industry f) { …… }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    method </span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">doForSightSeeing</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(SightSeeing ss) { …… }</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    ## ……</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但我们究竟应该如何调用这些方法 （尤其是在处理整个图像方面） 呢？ 这些方法的签名各不相同， 因此我们不能使用多态机制。 为了可以挑选出能够处理特定对象的访问者方法， 我们需要对它的类进行检查。 这是不是听上去像个噩梦呢？</p><div class="language-ts line-numbers-mode" data-highlighter="shiki" data-ext="ts" data-title="ts" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">foreach</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">Node</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> node</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> in</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> graph</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">node</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> instanceof</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> City</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">        exportVisitor</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">doForCity</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">((</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">City</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">node</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">node</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> instanceof</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Industry</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">        exportVisitor</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">doForIndustry</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">((</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">Industry</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">node</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    ## ……</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>你可能会问， 我们为什么不使用方法重载呢？ 就是使用相同的方法名称， 但它们的参数不同。 不幸的是， 即使我们的编程语言 （例如 Java 和 C#） 支持重载也不行。 由于我们无法提前知晓节点对象所属的类， 所以重载机制无法执行正确的方法。 方法会将 节点基类作为输入参数的默认类型。</p><p>但是， 访问者模式可以解决这个问题。 它使用了一种名为双分派的技巧， 不使用累赘的条件语句也可下执行正确的方法。 与其让客户端来选择调用正确版本的方法， 不如将选择权委派给作为参数传递给访问者的对象。 由于该对象知晓其自身的类， 因此能更自然地在访问者中选出正确的方法。 它们会 “接收” 一个访问者并告诉其应执行的访问者方法。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>## 客户端代码</span></span>\n<span class="line"><span>foreach (Node node in graph)</span></span>\n<span class="line"><span>    node.accept(exportVisitor)</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>## 城市</span></span>\n<span class="line"><span>class City is</span></span>\n<span class="line"><span>    method accept(Visitor v) is</span></span>\n<span class="line"><span>        v.doForCity(this)</span></span>\n<span class="line"><span>    ## ……</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>## 工业区</span></span>\n<span class="line"><span>class Industry is</span></span>\n<span class="line"><span>    method accept(Visitor v) is</span></span>\n<span class="line"><span>        v.doForIndustry(this)</span></span>\n<span class="line"><span>    ## ……</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我承认最终还是修改了节点类， 但毕竟改动很小， 且使得我们能够在后续进一步添加行为时无需再次修改代码。</p><p>现在， 如果我们抽取出所有访问者的通用接口， 所有已有的节点都能与我们在程序中引入的任何访问者交互。 如果需要引入与节点相关的某个行为， 你只需要实现一个新的访问者类即可。</p><h2 id="真实世界类比" tabindex="-1"><a class="header-anchor" href="#真实世界类比"><span>真实世界类比</span></a></h2><figure><img src="'+h+'" alt="优秀的保险代理人总能为不同类型的团体提供不同的保单。" tabindex="0" loading="lazy"><figcaption>优秀的保险代理人总能为不同类型的团体提供不同的保单。</figcaption></figure><p>假如有这样一位非常希望赢得新客户的资深保险代理人。 他可以拜访街区中的每栋楼， 尝试向每个路人推销保险。 所以， 根据大楼内组织类型的不同， 他可以提供专门的保单：</p><ul><li>如果建筑是居民楼， 他会推销医疗保险。</li><li>如果建筑是银行， 他会推销失窃保险。</li><li>如果建筑是咖啡厅， 他会推销火灾和洪水保险。</li></ul><h2 id="访问者模式结构" tabindex="-1"><a class="header-anchor" href="#访问者模式结构"><span>访问者模式结构</span></a></h2><figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol><li><strong>访问者</strong> （Visitor） 接口声明了一系列以对象结构的具体元素为参数的访问者方法。 如果编程语言支持重载， 这些方法的名称可以是相同的， 但是其参数一定是不同的。</li><li><strong>具体访问者</strong> （Concrete Visitor） 会为不同的具体元素类实现相同行为的几个不同版本。</li><li><strong>元素</strong> （Element） 接口声明了一个方法来 “接收” 访问者。 该方法必须有一个参数被声明为访问者接口类型。</li><li><strong>具体元素</strong> （Concrete Element） 必须实现接收方法。 该方法的目的是根据当前元素类将其调用重定向到相应访问者的方法。 请注意， 即使元素基类实现了该方法， 所有子类都必须对其进行重写并调用访问者对象中的合适方法。</li><li><strong>客户端</strong> （Client） 通常会作为集合或其他复杂对象 （例如一个组合树） 的代表。 客户端通常不知晓所有的具体元素类， 因为它们会通过抽象接口与集合中的对象进行交互。</li></ol><h2 id="伪代码" tabindex="-1"><a class="header-anchor" href="#伪代码"><span>伪代码</span></a></h2><p>在本例中， 访问者模式为几何图像层次结构添加了对于 XML 文件导出功能的支持。<br><img src="'+k+'" alt="通过访问者对象将各种类型的对象导出为 XML 格式文件。" loading="lazy"></p><div class="language-py line-numbers-mode" data-highlighter="shiki" data-ext="py" data-title="py" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">## 元素接口声明了一个`accept（接收）`方法，它会将访问者基础接口作为一个参</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">## 数。</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">interface Shape </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">is</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">   method </span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">move</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(x, y)</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">   method </span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">draw</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">   method </span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">accept</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(v: Visitor)</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">## 每个具体元素类都必须以特定方式实现`accept`方法，使其能调用相应元素类的</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">## 访问者方法。</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> Dot implements Shape </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">is</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">   ## ……</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">   ## 注意我们正在调用的`visitDot（访问点）`方法与当前类的名称相匹配。</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">   ## 这样我们能让访问者知晓与其交互的元素类。</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">   method </span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">accept</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(v: Visitor) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">is</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">       v.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">visitDot</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(this)</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> Circle implements Shape </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">is</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">   ## ……</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">   method </span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">accept</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(v: Visitor) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">is</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">       v.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">visitCircle</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(this)</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> Rectangle implements Shape </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">is</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">   ## ……</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">   method </span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">accept</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(v: Visitor) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">is</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">       v.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">visitRectangle</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(this)</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> CompoundShape implements Shape </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">is</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">   ## ……</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">   method </span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">accept</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(v: Visitor) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">is</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">       v.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">visitCompoundShape</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(this)</span></span>\n<span class="line"></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">## 访问者接口声明了一组与元素类对应的访问方法。访问方法的签名能让访问者准</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">## 确辨别出与其交互的元素所属的类。</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">interface Visitor </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">is</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">   method </span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">visitDot</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(d: Dot)</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">   method </span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">visitCircle</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(c: Circle)</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">   method </span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">visitRectangle</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(r: Rectangle)</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">   method </span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">visitCompoundShape</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(cs: CompoundShape)</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">## 具体访问者实现了同一算法的多个版本，而且该算法能与所有具体类进行交互。</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">//</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">## 访问者模式在复杂对象结构（例如组合树）上使用时能发挥最大作用。在这种情</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">## 况下，它可以存储算法的一些中间状态，并同时在结构中的不同对象上执行访问</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">## 者方法。这可能会非常有帮助。</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> XMLExportVisitor implements Visitor </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">is</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">   method </span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">visitDot</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(d: Dot) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">is</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">       ## 导出点（dot）的 ID 和中心坐标。</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">   method </span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">visitCircle</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(c: Circle) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">is</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">       ## 导出圆（circle）的 ID 、中心坐标和半径。</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">   method </span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">visitRectangle</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(r: Rectangle) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">is</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">       ## 导出长方形（rectangle）的 ID 、左上角坐标、宽和长。</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">   method </span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">visitCompoundShape</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(cs: CompoundShape) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">is</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">       ## 导出图形（shape）的 ID 和其子项目的 ID 列表。</span></span>\n<span class="line"></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">## 客户端代码可在不知晓具体类的情况下在一组元素上运行访问者操作。“接收”操</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">## 作会将调用定位到访问者对象的相应操作上。</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> Application </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">is</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">   field allShapes: array of Shapes</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">   method </span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">export</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">is</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">       exportVisitor </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> new </span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">XMLExportVisitor</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">       foreach</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (shape </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">in</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> allShapes) do</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">           shape.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">accept</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(exportVisitor)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="访问者模式优缺点" tabindex="-1"><a class="header-anchor" href="#访问者模式优缺点"><span>访问者模式优缺点</span></a></h2><p>√ <strong>开闭原则</strong>。 你可以引入在不同类对象上执行的新行为， 且无需对这些类做出修改。<br> √ <strong>单一职责原则</strong>。 可将同一行为的不同版本移到同一个类中。<br> √ 访问者对象可以在与各种对象交互时收集一些有用的信息。 当你想要遍历一些复杂的对象结构 （例如对象树）， 并在结构中的每个对象上应用访问者时， 这些信息可能会有所帮助。<br> × 每次在元素层次结构中添加或移除一个类时， 你都要更新所有的访问者。<br> × 在访问者同某个元素进行交互时， 它们可能没有访问元素私有成员变量和方法的必要权限。</p><h2 id="与其他模式的关系" tabindex="-1"><a class="header-anchor" href="#与其他模式的关系"><span>与其他模式的关系</span></a></h2>',35)),(0,n.Lk)("ul",null,[(0,n.Lk)("li",null,[(0,n.Lk)("p",null,[s[1]||(s[1]=(0,n.eW)("你可以将")),s[2]||(s[2]=(0,n.Lk)("strong",null,"访问者模式",-1)),s[3]||(s[3]=(0,n.eW)("视为")),(0,n.bF)(a,{to:"/posts/more-than-code/design-patterns/behavioral/command.html"},{default:(0,n.k6)((()=>s[0]||(s[0]=[(0,n.Lk)("strong",null,"命令模式",-1)]))),_:1}),s[4]||(s[4]=(0,n.eW)("的加强版本， 其对象可对不同类的多种对象执行操作。"))])]),(0,n.Lk)("li",null,[(0,n.Lk)("p",null,[s[6]||(s[6]=(0,n.eW)("你可以使用")),s[7]||(s[7]=(0,n.Lk)("strong",null,"访问者",-1)),s[8]||(s[8]=(0,n.eW)("对整个")),(0,n.bF)(a,{to:"/posts/more-than-code/design-patterns/structural/composite.html"},{default:(0,n.k6)((()=>s[5]||(s[5]=[(0,n.Lk)("strong",null,"组合模式",-1)]))),_:1}),s[9]||(s[9]=(0,n.eW)("树执行操作。"))])]),(0,n.Lk)("li",null,[(0,n.Lk)("p",null,[s[11]||(s[11]=(0,n.eW)("可以同时使用")),s[12]||(s[12]=(0,n.Lk)("strong",null,"访问者",-1)),s[13]||(s[13]=(0,n.eW)("和")),(0,n.bF)(a,{to:"/posts/more-than-code/design-patterns/behavioral/iterator.html"},{default:(0,n.k6)((()=>s[10]||(s[10]=[(0,n.Lk)("strong",null,"迭代器模式",-1)]))),_:1}),s[14]||(s[14]=(0,n.eW)("来遍历复杂数据结构， 并对其中的元素执行所需操作， 即使这些元素所属的类完全不同。"))])])])])}]]),c=JSON.parse('{"path":"/posts/more-than-code/design-patterns/behavioral/visitor.html","title":"访问者模式","lang":"zh-CN","frontmatter":{"title":"访问者模式","icon":"/assets/images/more-than-code/design-patterns/behavioral/visitor/visitor-mini.png","order":10,"category":["设计模式"],"description":"意图 访问者模式是一种行为设计模式， 它能将算法与其所作用的对象隔离开来。 问题 假如你的团队开发了一款能够使用巨型图像中地理信息的应用程序。 图像中的每个节点既能代表复杂实体 （例如一座城市）， 也能代表更精细的对象 （例如工业区和旅游景点等）。 如果节点代表的真实对象之间存在公路， 那么这些节点就会相互连接。 在程序内部， 每个节点的类型都由其所属...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/blog/posts/more-than-code/design-patterns/behavioral/visitor.html"}],["meta",{"property":"og:site_name","content":"大喵喜的杂货铺"}],["meta",{"property":"og:title","content":"访问者模式"}],["meta",{"property":"og:description","content":"意图 访问者模式是一种行为设计模式， 它能将算法与其所作用的对象隔离开来。 问题 假如你的团队开发了一款能够使用巨型图像中地理信息的应用程序。 图像中的每个节点既能代表复杂实体 （例如一座城市）， 也能代表更精细的对象 （例如工业区和旅游景点等）。 如果节点代表的真实对象之间存在公路， 那么这些节点就会相互连接。 在程序内部， 每个节点的类型都由其所属..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-05-07T09:02:49.000Z"}],["meta",{"property":"article:modified_time","content":"2025-05-07T09:02:49.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"访问者模式\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-05-07T09:02:49.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Jianshu.Shi\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"意图","slug":"意图","link":"#意图","children":[]},{"level":2,"title":"问题","slug":"问题","link":"#问题","children":[]},{"level":2,"title":"解决方案","slug":"解决方案","link":"#解决方案","children":[]},{"level":2,"title":"真实世界类比","slug":"真实世界类比","link":"#真实世界类比","children":[]},{"level":2,"title":"访问者模式结构","slug":"访问者模式结构","link":"#访问者模式结构","children":[]},{"level":2,"title":"伪代码","slug":"伪代码","link":"#伪代码","children":[]},{"level":2,"title":"访问者模式优缺点","slug":"访问者模式优缺点","link":"#访问者模式优缺点","children":[]},{"level":2,"title":"与其他模式的关系","slug":"与其他模式的关系","link":"#与其他模式的关系","children":[]}],"git":{"createdTime":1741180358000,"updatedTime":1746608569000,"contributors":[{"name":"damiaoxi","username":"damiaoxi","email":"miaoxi1110@gmail.com","commits":1,"url":"https://github.com/damiaoxi"},{"name":"Jianshu","username":"Jianshu","email":"jianshu.shi@eisgroup.com","commits":3,"url":"https://github.com/Jianshu"}]},"readingTime":{"minutes":8.85,"words":2656},"localizedDate":"2025年3月5日","excerpt":"<h2>意图</h2>\\n<p>访问者模式是一种行为设计模式， 它能将算法与其所作用的对象隔离开来。</p>\\n<figure><figcaption></figcaption></figure>\\n<h2>问题</h2>\\n<p>假如你的团队开发了一款能够使用巨型图像中地理信息的应用程序。 图像中的每个节点既能代表复杂实体 （例如一座城市）， 也能代表更精细的对象 （例如工业区和旅游景点等）。 如果节点代表的真实对象之间存在公路， 那么这些节点就会相互连接。 在程序内部， 每个节点的类型都由其所属的类来表示， 每个特定的节点则是一个对象。</p>\\n<figure><figcaption>将图像导出为 XML。</figcaption></figure>","autoDesc":true}')}}]);