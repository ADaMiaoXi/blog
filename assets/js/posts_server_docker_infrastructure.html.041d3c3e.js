"use strict";(self.webpackChunkmiaoxi_blog=self.webpackChunkmiaoxi_blog||[]).push([[4014],{66262:(e,r)=>{r.A=(e,r)=>{const t=e.__vccOpts||e;for(const[e,o]of r)t[e]=o;return t}},67500:(e,r,t)=>{t.r(r),t.d(r,{comp:()=>d,data:()=>a});var o=t(20641);const i=t.p+"assets/img/docker-infra.590a32d3.png",c=t.p+"assets/img/docker-vm-comparision.24c38971.png",n={},d=(0,t(66262).A)(n,[["render",function(e,r){const t=(0,o.g2)("font");return(0,o.uX)(),(0,o.CE)("div",null,[r[4]||(r[4]=(0,o.Fv)('<h2 id="docker-运行的基本流程" tabindex="-1"><a class="header-anchor" href="#docker-运行的基本流程"><span>Docker 运行的基本流程：</span></a></h2><ol><li><p>用户是使用 Docker Client 与 Docker Daemon 建立通信，并发送请求给后者。</p></li><li><p>Docker Daemon 作为 Docker 架构中的主体部分，首先提供 Docker Server 的功能使其可以接受 Docker Client 的请求。</p></li><li><p>Docker Engine 执行 Docker 内部的一系列工作，每一项工作都是以一个 Job 的形式的存在。</p></li><li><p>Job 的运行过程中，当需要容器镜像时，则从 Docker Registry 中下载镜像，并通过镜像管理驱动 Graph driver 将下载镜像以 Graph 的形式存储。</p></li><li><p>当需要为 Docker 创建网络环境时，通过网络管理驱动 Network driver 创建并配置 Docker 容器网络环境。</p></li><li><p>当需要限制 Docker 容器运行资源或执行用户指令等操作时，则通过 Exec driver 来完成。</p></li><li><p>Libcontainer 是一项独立的容器管理包，Network driver 以及 Exec driver 都是通过 Libcontainer 来实现具体对容器进行的操作。</p></li></ol><figure><img src="'+i+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="为什么-docker-会比-vm-虚拟机快" tabindex="-1"><a class="header-anchor" href="#为什么-docker-会比-vm-虚拟机快"><span>为什么 Docker 会比 VM 虚拟机快</span></a></h2>',4)),(0,o.Lk)("ol",null,[(0,o.Lk)("li",null,[(0,o.bF)(t,{color:"blue"},{default:(0,o.k6)((()=>r[0]||(r[0]=[(0,o.eW)("docker 有着比虚拟机更少的抽象层")]))),_:1}),r[1]||(r[1]=(0,o.Lk)("p",null,[(0,o.eW)("由于 docker 不需要 Hypervisor(虚拟机)实现硬件资源虚拟化,运行在 docker 容器上的程序直接使用的都是实际物理机的硬件资源。因此在 CPU、内存利用率上 docker 将会在效率上有明显优势。"),(0,o.Lk)("br"),(0,o.Lk)("img",{src:c,alt:"",loading:"lazy"})],-1))]),(0,o.Lk)("li",null,[(0,o.bF)(t,{color:"blue"},{default:(0,o.k6)((()=>r[2]||(r[2]=[(0,o.eW)("docker 利用的是宿主机的内核,而不需要加载操作系统 OS 内核")]))),_:1}),r[3]||(r[3]=(0,o.Fv)("<p>当新建一个容器时,docker 不需要和虚拟机一样重新加载一个操作系统内核。进而避免引寻、加载操作系统内核返回等比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载 OS,返回新建过程是分钟级别的。而 docker 由于直接利用宿主机的操作系统,则省略了返回过程,因此新建一个 docker 容器只需要几秒钟。</p><table><thead><tr><th></th><th>Docker 容器</th><th>虚拟机</th></tr></thead><tbody><tr><td>操作系统</td><td>与宿主机共享 OS</td><td>宿主机 OS 上运行虚拟机 OS</td></tr><tr><td>存储大小</td><td>镜像小，便于储存与传输</td><td>镜像庞大</td></tr><tr><td>运行性能</td><td>几乎无额外损失</td><td>有操作系统额外的 CPU、内存消耗</td></tr><tr><td>移植性</td><td>轻便、灵活，适应于 Linux</td><td>笨重，与虚拟化技术耦合度高</td></tr><tr><td>硬件亲和性</td><td>软件开发者</td><td>硬件运维者</td></tr><tr><td>部署速度</td><td>快（秒级）</td><td>较慢（10S 以上）</td></tr></tbody></table>",2))])])])}]]),a=JSON.parse('{"path":"/posts/server/docker/infrastructure.html","title":"架构模式","lang":"zh-CN","frontmatter":{"title":"架构模式","icon":"clarity:command-line","order":3,"category":["Docker"],"description":"Docker 运行的基本流程： 用户是使用 Docker Client 与 Docker Daemon 建立通信，并发送请求给后者。 Docker Daemon 作为 Docker 架构中的主体部分，首先提供 Docker Server 的功能使其可以接受 Docker Client 的请求。 Docker Engine 执行 Docker 内部的一系...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/blog/posts/server/docker/infrastructure.html"}],["meta",{"property":"og:site_name","content":"大喵喜的技术杂货铺"}],["meta",{"property":"og:title","content":"架构模式"}],["meta",{"property":"og:description","content":"Docker 运行的基本流程： 用户是使用 Docker Client 与 Docker Daemon 建立通信，并发送请求给后者。 Docker Daemon 作为 Docker 架构中的主体部分，首先提供 Docker Server 的功能使其可以接受 Docker Client 的请求。 Docker Engine 执行 Docker 内部的一系..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-05-19T00:19:02.000Z"}],["meta",{"property":"article:modified_time","content":"2025-05-19T00:19:02.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"架构模式\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-05-19T00:19:02.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Jianshu.Shi\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"Docker 运行的基本流程：","slug":"docker-运行的基本流程","link":"#docker-运行的基本流程","children":[]},{"level":2,"title":"为什么 Docker 会比 VM 虚拟机快","slug":"为什么-docker-会比-vm-虚拟机快","link":"#为什么-docker-会比-vm-虚拟机快","children":[]}],"git":{"createdTime":1747613942000,"updatedTime":1747613942000,"contributors":[{"name":"damiaoxi","username":"damiaoxi","email":"miaoxi1110@gmail.com","commits":1,"url":"https://github.com/damiaoxi"}]},"readingTime":{"minutes":2.13,"words":639},"localizedDate":"2025年5月19日","excerpt":"<h2>Docker 运行的基本流程：</h2>\\n<ol>\\n<li>\\n<p>用户是使用 Docker Client 与 Docker Daemon 建立通信，并发送请求给后者。</p>\\n</li>\\n<li>\\n<p>Docker Daemon 作为 Docker 架构中的主体部分，首先提供 Docker Server 的功能使其可以接受 Docker Client 的请求。</p>\\n</li>\\n<li>\\n<p>Docker Engine 执行 Docker 内部的一系列工作，每一项工作都是以一个 Job 的形式的存在。</p>\\n</li>\\n<li>\\n<p>Job 的运行过程中，当需要容器镜像时，则从 Docker Registry 中下载镜像，并通过镜像管理驱动 Graph driver 将下载镜像以 Graph 的形式存储。</p>\\n</li>\\n<li>\\n<p>当需要为 Docker 创建网络环境时，通过网络管理驱动 Network driver 创建并配置 Docker 容器网络环境。</p>\\n</li>\\n<li>\\n<p>当需要限制 Docker 容器运行资源或执行用户指令等操作时，则通过 Exec driver 来完成。</p>\\n</li>\\n<li>\\n<p>Libcontainer 是一项独立的容器管理包，Network driver 以及 Exec driver 都是通过 Libcontainer 来实现具体对容器进行的操作。</p>\\n</li>\\n</ol>","autoDesc":true}')}}]);